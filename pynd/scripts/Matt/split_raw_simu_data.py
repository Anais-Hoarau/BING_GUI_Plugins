"""
This script splits the monolitic CSV files generated by the MSSQL database storing the CosmoSivic simulation data by
subjects and scenarios to allow easier manipulation.
"""

import os
import csv
import codecs
from datetime import datetime as dt
import logging as log
from dirs import DIR_DATA_SPLIT, DIR_SIMU

DUPLICATE_SCENARIO_SEPARATOR = "__________"


def str2time(jc_time):
    return dt.strptime(jc_time, "%Y/%m/%d %H:%M:%S:%f")


def time2str(t):
    return t.strftime("%Y/%m/%d %H:%M:%S:%f")


class Subject:
    """Class to store all scenarios' metadata for a participant"""

    def __init__(self, name):
        self.name = name
        self.scenarios = {}

    def add_scenario(self, scenario):
        """
        Adds a scenario for the subject. If the same scenario already exists, the new one will be renamed
        :param scenario: The scenario to add
        :return:
        """
        # If there's a duplicate scenario for the subject, we add it under a new name (scenario_X)
        if scenario.name in self.scenarios:
            log.debug("Duplicate: %s, %s" % (self.name, scenario.name))
            i = 1
            while True:
                scenario_name_sub = scenario.name + DUPLICATE_SCENARIO_SEPARATOR + str(i)
                if scenario_name_sub not in self.scenarios:
                    scenario.name = scenario_name_sub
                    break
                i += 1
        self.scenarios[scenario.name] = scenario


class Scenario:
    """Class to store metadata (time) for a scenario"""

    def __init__(self, name, time_begin, time_end):
        self.name = name
        self.time_begin = time_begin
        self.time_end = time_end


def get_trips(subdir):
    """Returns all trips base data as a dict which key is the trip starting time and value is the path where the split
    up trip data should be stored"""
    log.info("Loading trips")
    subjects_fn = os.path.join(subdir, "sujet.csv")
    subjects = {}
    with codecs.open(subjects_fn, 'rU', 'utf-16') as v:
        subjects_reader = csv.reader(v, delimiter=';')
        prev_scenario = None
        for l in subjects_reader:
            subject_name = l[0]
            scenario_name = l[1]
            time_begin = str2time(l[2])
            if prev_scenario:
                # End time is starting time of the next scenario (bug within the simulator)
                prev_scenario.time_end = time_begin
            scenario = Scenario(scenario_name, time_begin, str2time(l[3]))
            try:
                subject = subjects[subject_name]
            except KeyError:
                subject = Subject(subject_name)
                subjects[subject_name] = subject
            subject.add_scenario(scenario)
            prev_scenario = scenario

    # Restructuring data so it's sorted by time, and has the desination folder
    scenario_times = {}
    for subject in subjects.values():
        for scenario in subject.scenarios.values():
            if scenario is not None:
                scenario_times[scenario.time_begin] = os.path.join(DIR_DATA_SPLIT, subject.name, scenario.name)
    return scenario_times


def split_file(subdir, trips, filename, file_time_idx):
    """
    Split any master CSV data file exported from the MSSQL database over all the subjects/scenarios subfolders. This
    allows easier navigation within data as it will be sorted.
    :param trips: All the trips metadata as returned by get_trips()
    :param filename: Name of the CSV file to split
    :param file_time_idx: Index of the column within the CSV file that holds timestamp data that will be used to match
    the data to the scenario's timestamps
    :return:
    """
    log.info("Splitting {filename}".format(filename=filename))
    times = sorted(trips.keys())
    time_idx = 0
    file_path = os.path.join(subdir, filename)
    if not os.path.exists(file_path):
        log.warning("Not file {f} in subdir {subdir}".format(f=filename, subdir=subdir))
        return
    with codecs.open(file_path, 'rU', 'utf-16') as f:
        times_count = len(times)
        lines = []
        l = f.readline()
        line_time = str2time(l.split(';')[file_time_idx])

        timer_start = dt.now()

        # Iterating over all scenarios' timecodes to find data
        while time_idx < times_count:
            can_split = False
            lower_bound = times[time_idx]
            if time_idx < (times_count - 1):
                upper_bound = times[time_idx + 1]
            else:
                # Hack to be able to export the last scenario's data (since the scenario's end timecode is bugged)
                upper_bound = dt.now()

            # If data's time is within the scenario's time range, we buffer the data
            while lower_bound <= line_time < upper_bound:
                lines.append(l)
                can_split = True
                l = f.readline()

                # No more data to process
                if not l:
                    break

                line_time = str2time(l.split(';')[file_time_idx])

            # If the buffered data is within the current scenario range, we export it
            if can_split:
                scenario_path = trips[times[time_idx]]
                scenario_file_path = os.path.join(scenario_path, filename)
                with open(scenario_file_path, "w") as scenario_file:
                    for line_export in lines:
                        log.debug("Line with time {line_time} moved to scenario which started at {scenario_begin}, "
                                  "ended at {scenario_end} and in folder {scenario_path}".format(
                            line_time=line_export.split(';')[file_time_idx],
                            scenario_begin=lower_bound,
                            scenario_end=upper_bound,
                            scenario_path=scenario_path))
                        scenario_file.write(line_export.strip() + '\n')
                lines = []
                can_split = False

            # No more data to process
            if not l:
                break

            time_idx += 1
            print("\r%3.2f%%" % (100 * time_idx / times_count), end='')
        print("\rCompleted in %s" % str(dt.now() - timer_start))


def build_subjects_folders(trips):
    """
    Builds all subjects and scenario subfolders based on trip metadata
    :param trips: All the trips metadata as returned by get_trips()
    :return:
    """
    for subject_path in trips.values():
        try:
            os.makedirs(subject_path)
        except OSError:
            pass


def split_raw_files():
    # Listing all subfolders where raw data is stored
    for d in os.listdir(DIR_SIMU):
        subdir = os.path.join(DIR_SIMU, d)
        if not os.path.isdir(subdir):
            continue
        log.info("Processing subfolder {dir}".format(dir=d))
        trips = get_trips(subdir)
        build_subjects_folders(trips)
        split_file(subdir, trips, "sujet.csv", 2)
        split_file(subdir, trips, "freeze.csv", 1)
        split_file(subdir, trips, "keyboardvalues.csv", 0)
        split_file(subdir, trips, "ego.csv", 0)
        split_file(subdir, trips, "vehicule.csv", 0)


def main():
    log.basicConfig(format='%(asctime)-15s [%(levelname)-8s]: %(message)s', level=log.INFO)
    split_raw_files()


if __name__ == "__main__":
    main()
