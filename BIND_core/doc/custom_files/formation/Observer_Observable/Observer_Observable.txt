Title: 4.Observer /  Observable

Introduction: 
Observer / Observable est le nom d'un motif de conception (ou design pattern) utilisé pour décorréler un modèle de données (l'observable), sous la forme d'un objet, d'un ensemble d'objets qui réagissent aux modifications du modèle de données (les observers). On obtient ainsi un couplage lache (créé uniquement à l'instanciation et non codé en dur), qui permet une plus grande réutilisabilité de l'Observable, et permet également de construire plus simplement des systèmes de type plugins.
On trouvera également des informations sur les patterns en général et celui-ci en particulier sur <http://en.wikipedia.org/wiki/Design_pattern_(computer_science)> . On notera en particulier les patterns Singleton, MVC, et Factory, qui sont très fréquemment utilisés.

Principe:
Le principe de ce design pattern est d'obtenir une série d'objets qui réagissent automatiquement aux modifications de l'Observable. On obtient ainsi une structure très adaptée à Dépouillement, puisqu'il s'agit d'afficher de manières multiples des données qui avancent chronologiquement, et qui seront donc notre Observable. Les plugins, qui réagissent à l'avancement de notre Observable, seront nos Observers.

Fonctionnement:
On possède un objet Observable, qui possède trois fonctions :
- s'ajouter un Observer
- s'enlever un Observer
- notifier tout ses observers

On possède également des objets Observers, qui possèdent la fonctionnalité suivante :
- être notifiés d'une modification de l'objet qu'ils observent.

Ainsi, une fois les différents objets instanciés, on appellera la méthode d'ajouts d'Observers sur l'Observable, en lui passant en paramètre les différents Observers. De cette manière, notre Observable possède désormais une référence vers tout les objets qui souhaitent être mis au courant de ses modifications. On ajoute au code métier de notre objet Observable un appel à la méthode de notification à chaque fois qu'on change l'étât du dit objet. Ainsi, chaque changement d'état sera notifié aux Observers via l'appel à leur méthode de notification. Cette méthode envoie un message donnant une indication sur la nature du changement. Libre ensuite à l'Observer de faire ce qu'il souhaite pour répercuter ces informations, comme par exemple mettre une interface graphique à jour.

Implémentation:
Afin de pouvoir obtenir une implémentation concrète du design pattern, nous aurons besoin de deux catégories d'objets :
- Un Observable, capable d'enregistrer quel sont ses observers, d'en désinscrire le cas échéant, et de les notifier des ses modifications
- Des Observers, qui suivent une structure commune, de manière à pouvoir être notifiés par l'Observable.
Comme on le voit, l'Observable à besoin d'un peu de code métier, alors que les Observers doivent simplement suivre une structure. C'est pourquoi Observable sera une classe, dont hériteront les objets qui doivent avoir ce comportement et Observer une interface, qui sera implémentée par les futurs Observers.

Les deux classes utilisées dans Dépouillement sont : 
- <depouillement.observation.Observable>
- <depouillement.observation.Observer>

Exercice d'application:
Nous allons réutiliser l'interface réalisée dans la formation 3 et la transformer en Observer. Nous créerons également une seconde classe d'Observer, en console cette fois-ci, ainsi qu'une petite classe "métier" Observable. Le diagramme UML donne les indications nécessaires (see Obs.png).

Un corrigé est diponible dans le dossier source de la documentation de cette formation.